{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Abel Documentation Abel is a lightweight microservices framework for Lua. It focuses on simple, fun experience of writing modular web services. Abel's name comes from abelo , which means bee in Esperanto. It further comes from abelujo , which means Hive (the project's former name). Abel is currently under heavy development, and many functionalities are yet to be implemented. Nevertheless, feel free to try it out, and any feedback would be appreciated! Getting Started There are a few places you can start reading: If you haven't learned Lua yet, the official Lua 5.4 reference is a good way to go. Manual contains introduction to aspects of Abel. API reference contains detailed definitions of Service and Sandbox APIs. Features Fully multi-threaded & asynchronous Writing, deploying and iterating Lua microservices without breaking a sweat Compliant to HTTP standards and JSON RESTful API conventions Sandbox environment, with limited yet powerful Lua API Basic Concepts Abel follows three major principles: Asynchronous. Reading a file, requesting an API, or other things that can be made asynchronous, will never block other instance to execute. Sandboxed. an Abel service can only access its own contained resources, and is fully blocked from the outside world. Standardized. Abel conforms with HTTP standards and RESTful JSON API conventions (unless you want to break them intentionally). Thanks to Rust , Tokio , Hyper and Lua (as well as its binding mlua ), these ideal designs are way easier to realize. Lua Version Compatibility Abel currently uses Lua 5.4 as its runtime. Lower versions and LuaJIT support is under consideration for now. License Abel is licensed under the MIT License.","title":"Home"},{"location":"#welcome-to-abel-documentation","text":"Abel is a lightweight microservices framework for Lua. It focuses on simple, fun experience of writing modular web services. Abel's name comes from abelo , which means bee in Esperanto. It further comes from abelujo , which means Hive (the project's former name). Abel is currently under heavy development, and many functionalities are yet to be implemented. Nevertheless, feel free to try it out, and any feedback would be appreciated!","title":"Welcome to Abel Documentation"},{"location":"#getting-started","text":"There are a few places you can start reading: If you haven't learned Lua yet, the official Lua 5.4 reference is a good way to go. Manual contains introduction to aspects of Abel. API reference contains detailed definitions of Service and Sandbox APIs.","title":"Getting Started"},{"location":"#features","text":"Fully multi-threaded & asynchronous Writing, deploying and iterating Lua microservices without breaking a sweat Compliant to HTTP standards and JSON RESTful API conventions Sandbox environment, with limited yet powerful Lua API","title":"Features"},{"location":"#basic-concepts","text":"Abel follows three major principles: Asynchronous. Reading a file, requesting an API, or other things that can be made asynchronous, will never block other instance to execute. Sandboxed. an Abel service can only access its own contained resources, and is fully blocked from the outside world. Standardized. Abel conforms with HTTP standards and RESTful JSON API conventions (unless you want to break them intentionally). Thanks to Rust , Tokio , Hyper and Lua (as well as its binding mlua ), these ideal designs are way easier to realize.","title":"Basic Concepts"},{"location":"#lua-version-compatibility","text":"Abel currently uses Lua 5.4 as its runtime. Lower versions and LuaJIT support is under consideration for now.","title":"Lua Version Compatibility"},{"location":"#license","text":"Abel is licensed under the MIT License.","title":"License"},{"location":"roadmap/","text":"Roadmap This is a (incomplete) list of upcoming features. Some of them have a tracking issue attached. Lua API Remote require #7 multipart/form-data support Static file serving Cron triggers Can be hashed (a.k.a. scheduling jitter), like the one used in Jenkins Function calls between services Workers (similar to Web Worker) User Experience Custom sandbox parameters (e.g. CPU timeout) Clients and dev utilities in abel CLI Wraps the REST API, while providing more such as packaging, custom script, pre- and post-deploy actions, and much more Like npm without pm (the package manager part is in remote require above) Hosting repository like deno.land/x Security HTTPS server","title":"Roadmap"},{"location":"roadmap/#roadmap","text":"This is a (incomplete) list of upcoming features. Some of them have a tracking issue attached.","title":"Roadmap"},{"location":"roadmap/#lua-api","text":"Remote require #7 multipart/form-data support Static file serving Cron triggers Can be hashed (a.k.a. scheduling jitter), like the one used in Jenkins Function calls between services Workers (similar to Web Worker)","title":"Lua API"},{"location":"roadmap/#user-experience","text":"Custom sandbox parameters (e.g. CPU timeout) Clients and dev utilities in abel CLI Wraps the REST API, while providing more such as packaging, custom script, pre- and post-deploy actions, and much more Like npm without pm (the package manager part is in remote require above) Hosting repository like deno.land/x","title":"User Experience"},{"location":"roadmap/#security","text":"HTTPS server","title":"Security"},{"location":"api/runtime/abel/","text":"Abel This contains APIs that is associated with Abel's executor, error handling, logic, etc. Methods abel.listen abel . listen ( path : string , handler : ( req : Request ) -> Response | Body ) Registers a path and listens to it. The path matches in listen 's calling order: first handler listen ed is first matched. For example: -- '/foo/bar' will go to `handler1`, while '/foo/baz' will go to `handler2`. abel . listen ( \"/foo/bar\" , handler1 ) abel . listen ( \"/foo/:value\" , handler2 ) -- However, if you switch the order of the two statements, even '/foo/bar' will be -- matched into `handler2` because '/foo/:value' matches first. abel . listen ( \"/foo/:value\" , handler2 ) abel . listen ( \"/foo/bar\" , handler1 ) abel.current_worker abel . current_worker () -> string Returns the current worker thread's name. Usually the names are abel-worker-{i} . abel.spawn abel . spawn < T > ( fn : ( ...args : any ) -> T , ...args : any ) -> Promise < T > Spawns a new task that runs on the same thread concurrently with the current one. It shares the same context with the task calling spawn . Returns a Promise that can be await ed at any time. abel.sleep abel . sleep ( ms : integer ) Pauses the currently running tasks for at least a certain period of time ms in milliseconds, letting other tasks on the same executor to run. It does not account for CPU time. When ms is set to zero, it has the same effect as coroutine.yield() , which simply hands over the control of the executor to other tasks. Fails if ms is negative. Fields abel.start abel . start ?: () -> any The service's start hook. If it's a function, it's called every time the service starts. abel.stop abel . stop ?: () -> any The service's start hook. If it's a function, it's called every time the service stops.","title":"Abel"},{"location":"api/runtime/abel/#abel","text":"This contains APIs that is associated with Abel's executor, error handling, logic, etc.","title":"Abel"},{"location":"api/runtime/abel/#methods","text":"","title":"Methods"},{"location":"api/runtime/abel/#abellisten","text":"abel . listen ( path : string , handler : ( req : Request ) -> Response | Body ) Registers a path and listens to it. The path matches in listen 's calling order: first handler listen ed is first matched. For example: -- '/foo/bar' will go to `handler1`, while '/foo/baz' will go to `handler2`. abel . listen ( \"/foo/bar\" , handler1 ) abel . listen ( \"/foo/:value\" , handler2 ) -- However, if you switch the order of the two statements, even '/foo/bar' will be -- matched into `handler2` because '/foo/:value' matches first. abel . listen ( \"/foo/:value\" , handler2 ) abel . listen ( \"/foo/bar\" , handler1 )","title":"abel.listen"},{"location":"api/runtime/abel/#abelcurrent_worker","text":"abel . current_worker () -> string Returns the current worker thread's name. Usually the names are abel-worker-{i} .","title":"abel.current_worker"},{"location":"api/runtime/abel/#abelspawn","text":"abel . spawn < T > ( fn : ( ...args : any ) -> T , ...args : any ) -> Promise < T > Spawns a new task that runs on the same thread concurrently with the current one. It shares the same context with the task calling spawn . Returns a Promise that can be await ed at any time.","title":"abel.spawn"},{"location":"api/runtime/abel/#abelsleep","text":"abel . sleep ( ms : integer ) Pauses the currently running tasks for at least a certain period of time ms in milliseconds, letting other tasks on the same executor to run. It does not account for CPU time. When ms is set to zero, it has the same effect as coroutine.yield() , which simply hands over the control of the executor to other tasks. Fails if ms is negative.","title":"abel.sleep"},{"location":"api/runtime/abel/#fields","text":"","title":"Fields"},{"location":"api/runtime/abel/#abelstart","text":"abel . start ?: () -> any The service's start hook. If it's a function, it's called every time the service starts.","title":"abel.start"},{"location":"api/runtime/abel/#abelstop","text":"abel . stop ?: () -> any The service's start hook. If it's a function, it's called every time the service stops.","title":"abel.stop"},{"location":"api/runtime/builtins/","text":"Builtins Methods HttpError HttpError ( error : { status? : integer , error? : string , detail? : Value | ( ...args : any ) -> Value , }) -> table Defines an custom HTTP error kind, allowing reuse with additional details. Examples -- Service 'int-echo' local NotAnInteger = HttpError { status = 400 , error = \"not an integer\" , detail = function ( got ) return { got = got } end } abel . listen ( \"/:n\" , function ( req ) local n = math.tointeger ( req . params . n ) if not n then error ( NotAnInteger ( req . params . n )) end return { int = n } end ) $ curl abel.example.com/int-echo/5 -v | jq < HTTP/1.1 200 OK { \"int\": 5 } $ curl abel.example.com/int-echo/3.14 -v | jq < HTTP/1.1 400 Bad Request { \"error\": \"not an integer\", \"got\": \"3.14\" } debug_fmt debug_fmt ( value : any ) -> string Formats the value into string in Rust debug style. bind bind < T > ( fn : ( ...args : any ) -> T , ...some : any ) -> ( ...other : any ) -> T Types Promise type Promise < T > = < userdata > A \"future value\", similar to those in JavaScript. Promise:await Promise < T >: await () -> T Waits for the value to resolve. This method also propagates error when resolving the value. Note that error is not propagated if await is not called.","title":"Builtins"},{"location":"api/runtime/builtins/#builtins","text":"","title":"Builtins"},{"location":"api/runtime/builtins/#methods","text":"","title":"Methods"},{"location":"api/runtime/builtins/#httperror","text":"HttpError ( error : { status? : integer , error? : string , detail? : Value | ( ...args : any ) -> Value , }) -> table Defines an custom HTTP error kind, allowing reuse with additional details.","title":"HttpError"},{"location":"api/runtime/builtins/#examples","text":"-- Service 'int-echo' local NotAnInteger = HttpError { status = 400 , error = \"not an integer\" , detail = function ( got ) return { got = got } end } abel . listen ( \"/:n\" , function ( req ) local n = math.tointeger ( req . params . n ) if not n then error ( NotAnInteger ( req . params . n )) end return { int = n } end ) $ curl abel.example.com/int-echo/5 -v | jq < HTTP/1.1 200 OK { \"int\": 5 } $ curl abel.example.com/int-echo/3.14 -v | jq < HTTP/1.1 400 Bad Request { \"error\": \"not an integer\", \"got\": \"3.14\" }","title":"Examples"},{"location":"api/runtime/builtins/#debug_fmt","text":"debug_fmt ( value : any ) -> string Formats the value into string in Rust debug style.","title":"debug_fmt"},{"location":"api/runtime/builtins/#bind","text":"bind < T > ( fn : ( ...args : any ) -> T , ...some : any ) -> ( ...other : any ) -> T","title":"bind"},{"location":"api/runtime/builtins/#types","text":"","title":"Types"},{"location":"api/runtime/builtins/#promise","text":"type Promise < T > = < userdata > A \"future value\", similar to those in JavaScript.","title":"Promise"},{"location":"api/runtime/builtins/#promiseawait","text":"Promise < T >: await () -> T Waits for the value to resolve. This method also propagates error when resolving the value. Note that error is not propagated if await is not called.","title":"Promise:await"},{"location":"api/runtime/crypto/","text":"Crypto Cryptographic utilities. local crypto = require \"crypto\" Types Rng type Rng = < userdata > A random number generator. Rng:random Rng : random () -> number Generates a random number from the range of [0, 1) . Rng:gen_range Rng : gen_range ( low : integer , high : integer ) -> integer Generates a random integer between low and high . Fields crypto.ThreadRng crypto.ThreadRng : Rng Thread-local random number generator. Internally uses rand::rngs::ThreadRng and provides cryptographically secure randomness.","title":"Crypto"},{"location":"api/runtime/crypto/#crypto","text":"Cryptographic utilities. local crypto = require \"crypto\"","title":"Crypto"},{"location":"api/runtime/crypto/#types","text":"","title":"Types"},{"location":"api/runtime/crypto/#rng","text":"type Rng = < userdata > A random number generator.","title":"Rng"},{"location":"api/runtime/crypto/#rngrandom","text":"Rng : random () -> number Generates a random number from the range of [0, 1) .","title":"Rng:random"},{"location":"api/runtime/crypto/#rnggen_range","text":"Rng : gen_range ( low : integer , high : integer ) -> integer Generates a random integer between low and high .","title":"Rng:gen_range"},{"location":"api/runtime/crypto/#fields","text":"","title":"Fields"},{"location":"api/runtime/crypto/#cryptothreadrng","text":"crypto.ThreadRng : Rng Thread-local random number generator. Internally uses rand::rngs::ThreadRng and provides cryptographically secure randomness.","title":"crypto.ThreadRng"},{"location":"api/runtime/fs/","text":"File System Provides access to a service's isolated file system. local fs = require \"fs\" Methods fs.open fs . open ( path : string , mode : \"r\" | \"w\" | \"a\" | \"r+\" | \"w+\" | \"a+\" ) -> File Opens the file. fs.type fs . type ( file : any ) -> nil | \"file\" | \"closed file\" Check if file is a file instance. Returns \"file\" if it is an open file, \"closed file\" if it is a closed one, or nil if it is not one. fs.mkdir fs . mkdir ( path : string , all? : boolean ) Creates a directory. Errors if path points to source. fs.rename fs . rename ( from : string , to : string ) Renames an entry. Errors if path points to source. fs.remove fs . remove ( path : string , all? : boolean ) Removes a file or directory. if all is set to true and path points to a directory that is not empty, it will remove all files inside it. Be careful! Errors if path points to source. fs.metadata fs . metadata ( path : string ) -> { kind : \"dir\" | \"file\" , size? : integer } Gets basic information about an entry. Types File type File : Stream < string > , BufStream , Sink < string > = < userdata > Representation of a file. File:read File : read ( ...modes : ReadMode ) -> ... string Reads some bytes from the file. When no arguments is passed, a random amount of bytes is returned, which is different from files from vanilla Lua and corresponds to Stream<string>:read . This method extends BufStream:read so that multiple read modes can be passed at the same time, returning multiple strings. File:write File : write ( ...bytes : string ) -> File Writes some bytes from the file. This method extends Sink<string>:write , allowing multiple bytes to be written once. File:seek File : seek ( whence : \"set\" | \"cur\" | \"end\" , pos : integer ) -> integer File:lines File : lines ( mode : stream.ReadMode ) -> iterator < string > File:flush File : flush () File:close File : close ()","title":"File System"},{"location":"api/runtime/fs/#file-system","text":"Provides access to a service's isolated file system. local fs = require \"fs\"","title":"File System"},{"location":"api/runtime/fs/#methods","text":"","title":"Methods"},{"location":"api/runtime/fs/#fsopen","text":"fs . open ( path : string , mode : \"r\" | \"w\" | \"a\" | \"r+\" | \"w+\" | \"a+\" ) -> File Opens the file.","title":"fs.open"},{"location":"api/runtime/fs/#fstype","text":"fs . type ( file : any ) -> nil | \"file\" | \"closed file\" Check if file is a file instance. Returns \"file\" if it is an open file, \"closed file\" if it is a closed one, or nil if it is not one.","title":"fs.type"},{"location":"api/runtime/fs/#fsmkdir","text":"fs . mkdir ( path : string , all? : boolean ) Creates a directory. Errors if path points to source.","title":"fs.mkdir"},{"location":"api/runtime/fs/#fsrename","text":"fs . rename ( from : string , to : string ) Renames an entry. Errors if path points to source.","title":"fs.rename"},{"location":"api/runtime/fs/#fsremove","text":"fs . remove ( path : string , all? : boolean ) Removes a file or directory. if all is set to true and path points to a directory that is not empty, it will remove all files inside it. Be careful! Errors if path points to source.","title":"fs.remove"},{"location":"api/runtime/fs/#fsmetadata","text":"fs . metadata ( path : string ) -> { kind : \"dir\" | \"file\" , size? : integer } Gets basic information about an entry.","title":"fs.metadata"},{"location":"api/runtime/fs/#types","text":"","title":"Types"},{"location":"api/runtime/fs/#file","text":"type File : Stream < string > , BufStream , Sink < string > = < userdata > Representation of a file.","title":"File"},{"location":"api/runtime/fs/#fileread","text":"File : read ( ...modes : ReadMode ) -> ... string Reads some bytes from the file. When no arguments is passed, a random amount of bytes is returned, which is different from files from vanilla Lua and corresponds to Stream<string>:read . This method extends BufStream:read so that multiple read modes can be passed at the same time, returning multiple strings.","title":"File:read"},{"location":"api/runtime/fs/#filewrite","text":"File : write ( ...bytes : string ) -> File Writes some bytes from the file. This method extends Sink<string>:write , allowing multiple bytes to be written once.","title":"File:write"},{"location":"api/runtime/fs/#fileseek","text":"File : seek ( whence : \"set\" | \"cur\" | \"end\" , pos : integer ) -> integer","title":"File:seek"},{"location":"api/runtime/fs/#filelines","text":"File : lines ( mode : stream.ReadMode ) -> iterator < string >","title":"File:lines"},{"location":"api/runtime/fs/#fileflush","text":"File : flush ()","title":"File:flush"},{"location":"api/runtime/fs/#fileclose","text":"File : close ()","title":"File:close"},{"location":"api/runtime/http/","text":"HTTP The HTTP module provides basic HTTP types, such as Request , Response and Uri , as well as a http.request function for easy requests. local http = require \"http\" Methods http.request http . request ( uri : string | Uri ) -> Response http . request ( req : { method? : string = \"GET\" , uri : string , headers ?: { [ key : string ] : string | string [] }, body? : Body , }) -> Response Sends an HTTP request. You can either use a single URI to send GET requests, or use other methods, add headers or a body with the latter builder table. For convenience, any underscore ( _ ) in headers ' keys is replaced with dash ( - ). To avoid that, use @ prefix: http . request { headers = { x_my_custom_header = \"foo bar\" -- sends `x-my-custom-header` } } http . request { headers = { [ \"@x_my_custom_header\" ] = \"foo bar\" -- sends \"x_my_custom_header\" } } Examples The simpliest usage is to send a GET request to the server using a single URI: local http = require \"http\" local resp , err = http . request \"https://httpbin.org/get\" assert ( resp , err ) Send an HTTP POST request with body and User-Agent header: local http = require \"http\" local resp , err = http . request { method = \"POST\" , uri = \"https://httpbin.org/post\" , body = \"Hello, world!\" , headers = { [ \"user-agent\" ] = \"abel/0.1.0\" } } assert ( resp , err ) Types Request type Request = < userdata > HTTP request representation. You don't need to manually create a Request yourself \u2014 either receive one in abel.listen 's handlers, or send one using a builder table in http.request . Request.method Request.method : string The request's method. Request.uri Request.uri : Uri The request's URI, parsed into Uri userdata. Request.headers Request.headers : HeaderMap The request's header map. Request.body Request.body : Body The request's body. Request.params Request . params : { [ key : string ] : string } Extracted path parameters. Only used in abel.listen 's handlers. Response type Response = < userdata > HTTP response representation. http.Response http . Response ( builder : { status? : integer = 200 , headers ?: { [ key : string ] : string | string [] }, body? : Body }) -> Response Response.status Response.status : integer Response.header Response.header : HeaderMap Response.body Response.body : Body Body type Body = nil | string | Value | Stream < string > HTTP body representation. It could be nil, a string, a JSON value, or a stream of strings. Note that the Body returned from methods or callbacks is always ByteStream . However, you can use one of the aforementioned types in custom requests and responses. Uri type Uri = < userdata > Parsed URI, either absolute or relative. http.Uri http . Uri ( uri : string ) -> Uri http . Uri ( builder : { scheme? : string , authority? : string , path_and_query? : string , path? : string , query? : QueryMap }) -> Uri Parses a URI from string, or build one using a builder table. Fragments in URIs are ignored, since these are not sent to the server in normal cases. Uri:query Uri : query () -> QueryMap Parses the query string of the URI, returning a map of query as QueryMap . Returns error if parsing query string failed. Examples local http = require \"http\" local uri = http . Uri \"https://example.com/?foo=bar&baz=hello%20world\" local query , err = uri : query () assert ( query , err ) -- Note that URI escapes are resolved (in this case the space `%20`) assert ( query . foo == \"bar\" ) assert ( query . baz == \"hello world\" ) Uri.scheme Uri.scheme : string Uri.host Uri.host : string Uri.port Uri.port : integer Uri.authority Uri.authority : string Uri.path Uri.path : string Uri.query_string Uri.query_string : string HeaderMap type HeaderMap = < userdata > Map of HTTP headers. Can be indexed or iterated using pairs . print ( \"The content type is: \" .. req . headers . content_type ) print \"Full header list:\" for k , v in pairs ( req . headers ) do print ( k .. \": \" .. v ) end When indexed, underscores ( _ ) can be used as dashes ( - ), as the above code shows. If you do want to access a field with underscores in its name, you can use @ prefix: local my_header = req . headers [ \"@header_with_underscore\" ] HeaderMap:get HeaderMap : get ( key : string ) -> ... string Get one or more header field of the name key . This method strictly matches its name, meaning that it does not replace underscores in key or use @ prefix. QueryMap type QueryMap = { [ key : string ] : string | string [] | QueryMap | QueryMap [] } Representing an URI's query structure, with multi-level support.","title":"HTTP"},{"location":"api/runtime/http/#http","text":"The HTTP module provides basic HTTP types, such as Request , Response and Uri , as well as a http.request function for easy requests. local http = require \"http\"","title":"HTTP"},{"location":"api/runtime/http/#methods","text":"","title":"Methods"},{"location":"api/runtime/http/#httprequest","text":"http . request ( uri : string | Uri ) -> Response http . request ( req : { method? : string = \"GET\" , uri : string , headers ?: { [ key : string ] : string | string [] }, body? : Body , }) -> Response Sends an HTTP request. You can either use a single URI to send GET requests, or use other methods, add headers or a body with the latter builder table. For convenience, any underscore ( _ ) in headers ' keys is replaced with dash ( - ). To avoid that, use @ prefix: http . request { headers = { x_my_custom_header = \"foo bar\" -- sends `x-my-custom-header` } } http . request { headers = { [ \"@x_my_custom_header\" ] = \"foo bar\" -- sends \"x_my_custom_header\" } }","title":"http.request"},{"location":"api/runtime/http/#examples","text":"The simpliest usage is to send a GET request to the server using a single URI: local http = require \"http\" local resp , err = http . request \"https://httpbin.org/get\" assert ( resp , err ) Send an HTTP POST request with body and User-Agent header: local http = require \"http\" local resp , err = http . request { method = \"POST\" , uri = \"https://httpbin.org/post\" , body = \"Hello, world!\" , headers = { [ \"user-agent\" ] = \"abel/0.1.0\" } } assert ( resp , err )","title":"Examples"},{"location":"api/runtime/http/#types","text":"","title":"Types"},{"location":"api/runtime/http/#request","text":"type Request = < userdata > HTTP request representation. You don't need to manually create a Request yourself \u2014 either receive one in abel.listen 's handlers, or send one using a builder table in http.request .","title":"Request"},{"location":"api/runtime/http/#requestmethod","text":"Request.method : string The request's method.","title":"Request.method"},{"location":"api/runtime/http/#requesturi","text":"Request.uri : Uri The request's URI, parsed into Uri userdata.","title":"Request.uri"},{"location":"api/runtime/http/#requestheaders","text":"Request.headers : HeaderMap The request's header map.","title":"Request.headers"},{"location":"api/runtime/http/#requestbody","text":"Request.body : Body The request's body.","title":"Request.body"},{"location":"api/runtime/http/#requestparams","text":"Request . params : { [ key : string ] : string } Extracted path parameters. Only used in abel.listen 's handlers.","title":"Request.params"},{"location":"api/runtime/http/#response","text":"type Response = < userdata > HTTP response representation.","title":"Response"},{"location":"api/runtime/http/#httpresponse","text":"http . Response ( builder : { status? : integer = 200 , headers ?: { [ key : string ] : string | string [] }, body? : Body }) -> Response","title":"http.Response"},{"location":"api/runtime/http/#responsestatus","text":"Response.status : integer","title":"Response.status"},{"location":"api/runtime/http/#responseheader","text":"Response.header : HeaderMap","title":"Response.header"},{"location":"api/runtime/http/#responsebody","text":"Response.body : Body","title":"Response.body"},{"location":"api/runtime/http/#body","text":"type Body = nil | string | Value | Stream < string > HTTP body representation. It could be nil, a string, a JSON value, or a stream of strings. Note that the Body returned from methods or callbacks is always ByteStream . However, you can use one of the aforementioned types in custom requests and responses.","title":"Body"},{"location":"api/runtime/http/#uri","text":"type Uri = < userdata > Parsed URI, either absolute or relative.","title":"Uri"},{"location":"api/runtime/http/#httpuri","text":"http . Uri ( uri : string ) -> Uri http . Uri ( builder : { scheme? : string , authority? : string , path_and_query? : string , path? : string , query? : QueryMap }) -> Uri Parses a URI from string, or build one using a builder table. Fragments in URIs are ignored, since these are not sent to the server in normal cases.","title":"http.Uri"},{"location":"api/runtime/http/#uriquery","text":"Uri : query () -> QueryMap Parses the query string of the URI, returning a map of query as QueryMap . Returns error if parsing query string failed.","title":"Uri:query"},{"location":"api/runtime/http/#examples_1","text":"local http = require \"http\" local uri = http . Uri \"https://example.com/?foo=bar&baz=hello%20world\" local query , err = uri : query () assert ( query , err ) -- Note that URI escapes are resolved (in this case the space `%20`) assert ( query . foo == \"bar\" ) assert ( query . baz == \"hello world\" )","title":"Examples"},{"location":"api/runtime/http/#urischeme","text":"Uri.scheme : string","title":"Uri.scheme"},{"location":"api/runtime/http/#urihost","text":"Uri.host : string","title":"Uri.host"},{"location":"api/runtime/http/#uriport","text":"Uri.port : integer","title":"Uri.port"},{"location":"api/runtime/http/#uriauthority","text":"Uri.authority : string","title":"Uri.authority"},{"location":"api/runtime/http/#uripath","text":"Uri.path : string","title":"Uri.path"},{"location":"api/runtime/http/#uriquery_string","text":"Uri.query_string : string","title":"Uri.query_string"},{"location":"api/runtime/http/#headermap","text":"type HeaderMap = < userdata > Map of HTTP headers. Can be indexed or iterated using pairs . print ( \"The content type is: \" .. req . headers . content_type ) print \"Full header list:\" for k , v in pairs ( req . headers ) do print ( k .. \": \" .. v ) end When indexed, underscores ( _ ) can be used as dashes ( - ), as the above code shows. If you do want to access a field with underscores in its name, you can use @ prefix: local my_header = req . headers [ \"@header_with_underscore\" ]","title":"HeaderMap"},{"location":"api/runtime/http/#headermapget","text":"HeaderMap : get ( key : string ) -> ... string Get one or more header field of the name key . This method strictly matches its name, meaning that it does not replace underscores in key or use @ prefix.","title":"HeaderMap:get"},{"location":"api/runtime/http/#querymap","text":"type QueryMap = { [ key : string ] : string | string [] | QueryMap | QueryMap [] } Representing an URI's query structure, with multi-level support.","title":"QueryMap"},{"location":"api/runtime/json/","text":"JSON local json = require \"json\" Methods json.parse json . parse ( str : string ) -> Value Parses the JSON string to value. json.stringify json . stringify ( value : Value , pretty? : boolean ) -> string Serializes the value into string. If pretty is set to true, the result string will be pretty-printed and indented, otherwise minimized. json.array json . array ( t : table ) -> table Marks the table t as array. json.undo_array json . undo_array ( t : table ) -> table Removes the array mark on table t , if exists. Types Value type Value = nil | boolean | number | string | Value [] | { [ key : string ] : Value } Valid JSON value. It could be one of nil (no such field or null), boolean, number, string, string-keyed table or array. Note that tables with recursion is invalid JSON value. Attempt to use them on json.stringify or other places will result in an error. Fields json.array_metatable json.array_metatable : table Metatable used to mark a table as array.","title":"JSON"},{"location":"api/runtime/json/#json","text":"local json = require \"json\"","title":"JSON"},{"location":"api/runtime/json/#methods","text":"","title":"Methods"},{"location":"api/runtime/json/#jsonparse","text":"json . parse ( str : string ) -> Value Parses the JSON string to value.","title":"json.parse"},{"location":"api/runtime/json/#jsonstringify","text":"json . stringify ( value : Value , pretty? : boolean ) -> string Serializes the value into string. If pretty is set to true, the result string will be pretty-printed and indented, otherwise minimized.","title":"json.stringify"},{"location":"api/runtime/json/#jsonarray","text":"json . array ( t : table ) -> table Marks the table t as array.","title":"json.array"},{"location":"api/runtime/json/#jsonundo_array","text":"json . undo_array ( t : table ) -> table Removes the array mark on table t , if exists.","title":"json.undo_array"},{"location":"api/runtime/json/#types","text":"","title":"Types"},{"location":"api/runtime/json/#value","text":"type Value = nil | boolean | number | string | Value [] | { [ key : string ] : Value } Valid JSON value. It could be one of nil (no such field or null), boolean, number, string, string-keyed table or array. Note that tables with recursion is invalid JSON value. Attempt to use them on json.stringify or other places will result in an error.","title":"Value"},{"location":"api/runtime/json/#fields","text":"","title":"Fields"},{"location":"api/runtime/json/#jsonarray_metatable","text":"json.array_metatable : table Metatable used to mark a table as array.","title":"json.array_metatable"},{"location":"api/runtime/stream/","text":"Stream A stream of values produced asynchronously, usually bytes (strings). local stream = require \"stream\" Internal Types Unless noted, most internal types that implements Stream , Sink or Transform have this module linked in its __index metamethod. Therefore, you should be able to do chain calls like this: req . body : pipe_through ( my_transform ) : pipe_to ( file ) instead of stream . pipe_to ( stream . pipe_through ( req . body , my_transform ), file ) Interfaces Stream interface Stream < T > { read : ( self ) -> T } BufStream interface BufStream extends Stream < string > { read : ( self , mode : ReadMode ) -> T } Sink interface Sink < T > { write : ( self , item : T ) -> nil } Transform interface Transform < T , U > { transform : ( self , item : T ) -> U } Types ByteStream type ByteStream : Stream < string > = < userdata > Native byte stream. ReadMode type ReadMode = integer | \"a\" | \"l\" | \"L\" Methods stream.read_all stream . read_all ( st : Stream < string > ) -> string stream.parse_json stream . parse_json ( st : Stream < string > ) -> Value stream.iter stream . iter < T > ( st : Stream < T > ) -> iterator < T > stream.from_iter stream . from_iter < T > ( iter : iterator < T > ) -> Stream < T > stream.pipe_to stream . pipe_to < T > ( st : Stream < T > , sink : Sink < T > ) stream.pipe_through stream . pipe_through < T , U > ( st : Stream < T > , tr : Transform < T , U > ) -> Stream < U > stream.recv_from stream . recv_from < T > ( sink : Sink < T > , st : Stream < T > ) stream.recv_through stream . recv_through < T , U > ( sink : Sink < U > , tr : Transform < T , U > ) -> Sink < T >","title":"Stream"},{"location":"api/runtime/stream/#stream","text":"A stream of values produced asynchronously, usually bytes (strings). local stream = require \"stream\"","title":"Stream"},{"location":"api/runtime/stream/#internal-types","text":"Unless noted, most internal types that implements Stream , Sink or Transform have this module linked in its __index metamethod. Therefore, you should be able to do chain calls like this: req . body : pipe_through ( my_transform ) : pipe_to ( file ) instead of stream . pipe_to ( stream . pipe_through ( req . body , my_transform ), file )","title":"Internal Types"},{"location":"api/runtime/stream/#interfaces","text":"","title":"Interfaces"},{"location":"api/runtime/stream/#stream_1","text":"interface Stream < T > { read : ( self ) -> T }","title":"Stream"},{"location":"api/runtime/stream/#bufstream","text":"interface BufStream extends Stream < string > { read : ( self , mode : ReadMode ) -> T }","title":"BufStream"},{"location":"api/runtime/stream/#sink","text":"interface Sink < T > { write : ( self , item : T ) -> nil }","title":"Sink"},{"location":"api/runtime/stream/#transform","text":"interface Transform < T , U > { transform : ( self , item : T ) -> U }","title":"Transform"},{"location":"api/runtime/stream/#types","text":"","title":"Types"},{"location":"api/runtime/stream/#bytestream","text":"type ByteStream : Stream < string > = < userdata > Native byte stream.","title":"ByteStream"},{"location":"api/runtime/stream/#readmode","text":"type ReadMode = integer | \"a\" | \"l\" | \"L\"","title":"ReadMode"},{"location":"api/runtime/stream/#methods","text":"","title":"Methods"},{"location":"api/runtime/stream/#streamread_all","text":"stream . read_all ( st : Stream < string > ) -> string","title":"stream.read_all"},{"location":"api/runtime/stream/#streamparse_json","text":"stream . parse_json ( st : Stream < string > ) -> Value","title":"stream.parse_json"},{"location":"api/runtime/stream/#streamiter","text":"stream . iter < T > ( st : Stream < T > ) -> iterator < T >","title":"stream.iter"},{"location":"api/runtime/stream/#streamfrom_iter","text":"stream . from_iter < T > ( iter : iterator < T > ) -> Stream < T >","title":"stream.from_iter"},{"location":"api/runtime/stream/#streampipe_to","text":"stream . pipe_to < T > ( st : Stream < T > , sink : Sink < T > )","title":"stream.pipe_to"},{"location":"api/runtime/stream/#streampipe_through","text":"stream . pipe_through < T , U > ( st : Stream < T > , tr : Transform < T , U > ) -> Stream < U >","title":"stream.pipe_through"},{"location":"api/runtime/stream/#streamrecv_from","text":"stream . recv_from < T > ( sink : Sink < T > , st : Stream < T > )","title":"stream.recv_from"},{"location":"api/runtime/stream/#streamrecv_through","text":"stream . recv_through < T , U > ( sink : Sink < U > , tr : Transform < T , U > ) -> Sink < T >","title":"stream.recv_through"},{"location":"api/runtime/testing/","text":"Testing Testing utilities. local testing = require \"testing\" Methods testing.assert testing . assert < T > ( value : T , msg? : any ) -> T Re-exported from assert Throws error if value is not a truthy value (all values except false and nil ), otherwise return it as is. testing.assert_false testing . assert_false ( value : any , msg? : any ) Throws error if value is a truthy value (all values except false and nil ). testing.assert_eq testing . assert_eq < T > ( left : T , right : T , msg? : any ) Throws error if left and right are not equal. testing.assert_ne testing . assert_ne < T > ( left : T , right : T , msg? : any ) Throws error if left and right are equal.","title":"Testing"},{"location":"api/runtime/testing/#testing","text":"Testing utilities. local testing = require \"testing\"","title":"Testing"},{"location":"api/runtime/testing/#methods","text":"","title":"Methods"},{"location":"api/runtime/testing/#testingassert","text":"testing . assert < T > ( value : T , msg? : any ) -> T Re-exported from assert Throws error if value is not a truthy value (all values except false and nil ), otherwise return it as is.","title":"testing.assert"},{"location":"api/runtime/testing/#testingassert_false","text":"testing . assert_false ( value : any , msg? : any ) Throws error if value is a truthy value (all values except false and nil ).","title":"testing.assert_false"},{"location":"api/runtime/testing/#testingassert_eq","text":"testing . assert_eq < T > ( left : T , right : T , msg? : any ) Throws error if left and right are not equal.","title":"testing.assert_eq"},{"location":"api/runtime/testing/#testingassert_ne","text":"testing . assert_ne < T > ( left : T , right : T , msg? : any ) Throws error if left and right are equal.","title":"testing.assert_ne"},{"location":"api/server/service/","text":"Service Service API is the HTTP interface of service management. Authentication Currently, Abel uses one UUID as authentication token, and is stored in $ABEL_PATH/config.json . To authorize yourself, you need to pass this token through Authorization header with the scheme Abel : $ curl https://abel.example.com/services \\ -H \"Authorization: Abel <your-auth-token>\" In the future, other authentication methods may be implemented. Methods GET /services Get all currently existing services. GET /services/:service Get the detailed information of a service. PUT /services/:service Uploads a service. Query mode : Specifies how the services should be uploaded. Available options are: create : Creates the service if it doesn't exist, and errors if it does. This is the default option. hot : Updates the service while not calling abel.start or abel.stop . Creates the service if it doesn't exist. cold : Stops the service, replaces its source and starts it again. Creates the service if it doesn't exist. load : Simply loads the service into the server without starting. Errors if the service exists. Multipart Fields single : Specifies a single-file service (a Lua source file). multi : Specifies a multi-file service (an asar archive). PATCH /services/:service Query op start stop DELETE /services/:service Deletes the service.","title":"Service"},{"location":"api/server/service/#service","text":"Service API is the HTTP interface of service management.","title":"Service"},{"location":"api/server/service/#authentication","text":"Currently, Abel uses one UUID as authentication token, and is stored in $ABEL_PATH/config.json . To authorize yourself, you need to pass this token through Authorization header with the scheme Abel : $ curl https://abel.example.com/services \\ -H \"Authorization: Abel <your-auth-token>\" In the future, other authentication methods may be implemented.","title":"Authentication"},{"location":"api/server/service/#methods","text":"","title":"Methods"},{"location":"api/server/service/#get-services","text":"Get all currently existing services.","title":"GET /services"},{"location":"api/server/service/#get-servicesservice","text":"Get the detailed information of a service.","title":"GET /services/:service"},{"location":"api/server/service/#put-servicesservice","text":"Uploads a service.","title":"PUT /services/:service"},{"location":"api/server/service/#query","text":"mode : Specifies how the services should be uploaded. Available options are: create : Creates the service if it doesn't exist, and errors if it does. This is the default option. hot : Updates the service while not calling abel.start or abel.stop . Creates the service if it doesn't exist. cold : Stops the service, replaces its source and starts it again. Creates the service if it doesn't exist. load : Simply loads the service into the server without starting. Errors if the service exists.","title":"Query"},{"location":"api/server/service/#multipart-fields","text":"single : Specifies a single-file service (a Lua source file). multi : Specifies a multi-file service (an asar archive).","title":"Multipart Fields"},{"location":"api/server/service/#patch-servicesservice","text":"","title":"PATCH /services/:service"},{"location":"api/server/service/#query_1","text":"op start stop","title":"Query"},{"location":"api/server/service/#delete-servicesservice","text":"Deletes the service.","title":"DELETE /services/:service"},{"location":"getting-started/deploy/","text":"Deploy Deploy Abel Simply run abel server to start the server: $ abel server INFO abel > Starting abel-server v0.1.0 INFO abel > Abel working path: $HOME/.abel INFO abel > Authentication token: <your-auth-token> INFO abel::server > Abel is listening to 127.0.0.1:3000 For server configuration, see Manual/Server/Configuration . Deploy Services Deploy your service with Abel is easier than ever. It only takes an HTTP request to upload the source code to the server and ready to run. via CLI $ abel deploy path/to/service \\ --server https://abel.example.com \\ --auth-token <your-auth-token> or use environment variables to specify them. This can be used along with tools like dotenv for your convenience. $ export ABEL_SERVER = https://abel.example.com $ export ABEL_AUTH_TOKEN = <your-auth-token> $ abel deploy path/to/service via HTTP Deploy your service using an HTTP client (here uses curl as example), with header Authorization: Abel <your-auth-token> : $ curl https://abel.example.com/services/awesome-service \\ -X PUT \\ -H \"Authorization: Abel <your-auth-token>\" \\ -F multi = @... | jq { \"new_service\": { \"name\": \"awesome-service\", // ... } } Now anyone can easily run it through HTTP. Easy, isn't it? $ curl https://abel.example.com/awesome-service For more methods to manage the service on the fly, see API/Server/Service .","title":"Deploy"},{"location":"getting-started/deploy/#deploy","text":"","title":"Deploy"},{"location":"getting-started/deploy/#deploy-abel","text":"Simply run abel server to start the server: $ abel server INFO abel > Starting abel-server v0.1.0 INFO abel > Abel working path: $HOME/.abel INFO abel > Authentication token: <your-auth-token> INFO abel::server > Abel is listening to 127.0.0.1:3000 For server configuration, see Manual/Server/Configuration .","title":"Deploy Abel"},{"location":"getting-started/deploy/#deploy-services","text":"Deploy your service with Abel is easier than ever. It only takes an HTTP request to upload the source code to the server and ready to run.","title":"Deploy Services"},{"location":"getting-started/deploy/#via-cli","text":"$ abel deploy path/to/service \\ --server https://abel.example.com \\ --auth-token <your-auth-token> or use environment variables to specify them. This can be used along with tools like dotenv for your convenience. $ export ABEL_SERVER = https://abel.example.com $ export ABEL_AUTH_TOKEN = <your-auth-token> $ abel deploy path/to/service","title":"via CLI"},{"location":"getting-started/deploy/#via-http","text":"Deploy your service using an HTTP client (here uses curl as example), with header Authorization: Abel <your-auth-token> : $ curl https://abel.example.com/services/awesome-service \\ -X PUT \\ -H \"Authorization: Abel <your-auth-token>\" \\ -F multi = @... | jq { \"new_service\": { \"name\": \"awesome-service\", // ... } } Now anyone can easily run it through HTTP. Easy, isn't it? $ curl https://abel.example.com/awesome-service For more methods to manage the service on the fly, see API/Server/Service .","title":"via HTTP"},{"location":"getting-started/hello-world/","text":"Hello, World The simpliest form of a Abel service is a single Lua file. So let's begin by creating a file named hello.lua : -- hello.lua local function hello ( req ) local name = req . params . name or \"world\" return { greeting = \"Hello, \" .. name .. \"!\" } end -- The former `listen` is to listen to the \"root path\", which will the default -- name \"world\". The latter one matches exactly one path segment, and extracts that -- segments into `req.params.name`. abel . listen ( \"/\" , hello ) abel . listen ( \"/:name\" , hello ) Start your Abel server in dev mode. This creates a temporary working environment for you to play on: $ abel dev hello.lua INFO abel > Starting abel-server v0.1.0 (dev mode) INFO abel::server > Loaded service (89a90b6b-2555-48ef-852d-9fc930a5a5e4) INFO abel::server > Abel is listening to 127.0.0.1:3000 Now your hello world should be ready. Access it through HTTP: $ curl 127 .0.0.1:3000/hello {\"greeting\":\"Hello, world!\"} $ curl 127 .0.0.1:3000/hello/Eric {\"greeting\":\"Hello, Eric!\"} In dev mode, Abel also watches the file for changes and hot update it. Try to modify hello.lua : return { greeting = \"Hello, \" .. name : upper () .. \"!\" } Then access it again. Now your name is screamed out! $ curl 127 .0.0.1:3000/hello {\"greeting\":\"Hello, WORLD!\"} $ curl 127 .0.0.1:3000/hello/Eric {\"greeting\":\"Hello, ERIC!\"} Voila! You just finished your first Abel service!","title":"Hello, World"},{"location":"getting-started/hello-world/#hello-world","text":"The simpliest form of a Abel service is a single Lua file. So let's begin by creating a file named hello.lua : -- hello.lua local function hello ( req ) local name = req . params . name or \"world\" return { greeting = \"Hello, \" .. name .. \"!\" } end -- The former `listen` is to listen to the \"root path\", which will the default -- name \"world\". The latter one matches exactly one path segment, and extracts that -- segments into `req.params.name`. abel . listen ( \"/\" , hello ) abel . listen ( \"/:name\" , hello ) Start your Abel server in dev mode. This creates a temporary working environment for you to play on: $ abel dev hello.lua INFO abel > Starting abel-server v0.1.0 (dev mode) INFO abel::server > Loaded service (89a90b6b-2555-48ef-852d-9fc930a5a5e4) INFO abel::server > Abel is listening to 127.0.0.1:3000 Now your hello world should be ready. Access it through HTTP: $ curl 127 .0.0.1:3000/hello {\"greeting\":\"Hello, world!\"} $ curl 127 .0.0.1:3000/hello/Eric {\"greeting\":\"Hello, Eric!\"} In dev mode, Abel also watches the file for changes and hot update it. Try to modify hello.lua : return { greeting = \"Hello, \" .. name : upper () .. \"!\" } Then access it again. Now your name is screamed out! $ curl 127 .0.0.1:3000/hello {\"greeting\":\"Hello, WORLD!\"} $ curl 127 .0.0.1:3000/hello/Eric {\"greeting\":\"Hello, ERIC!\"} Voila! You just finished your first Abel service!","title":"Hello, World"},{"location":"getting-started/installation/","text":"Installation Abel is tested to work on macOS, Linux and Windows on the x86-64 architecture. Other architectures may also work, it's just not tested. To try out Abel, use a prebuilt binary from Releases , or artifacts produced by GitHub Actions after every push. If there is no binary for your platform, or you want to contribute to Abel, you can also compile it yourself. Compile You need: Lastest stable version of Rust (upon Abel's version release) GCC or GCC-compatible C compilers (for compiling Lua) make (for compiling Lua) (On Linux) OpenSSL or LibreSSL development libraries (for example, libssl-dev on Debian and Ubuntu). Not necessary if using abel-core/tls-vendored feature flag. Lua 5.4, if abel-core/mlua-vendored flag is disabled. Clone and compile the project: $ git clone https://github.com/hack3ric/abel $ cd abel $ cargo install --path cli Install from Cargo Install the version published in crates.io : $ cargo install abel --locked","title":"Installation"},{"location":"getting-started/installation/#installation","text":"Abel is tested to work on macOS, Linux and Windows on the x86-64 architecture. Other architectures may also work, it's just not tested. To try out Abel, use a prebuilt binary from Releases , or artifacts produced by GitHub Actions after every push. If there is no binary for your platform, or you want to contribute to Abel, you can also compile it yourself.","title":"Installation"},{"location":"getting-started/installation/#compile","text":"You need: Lastest stable version of Rust (upon Abel's version release) GCC or GCC-compatible C compilers (for compiling Lua) make (for compiling Lua) (On Linux) OpenSSL or LibreSSL development libraries (for example, libssl-dev on Debian and Ubuntu). Not necessary if using abel-core/tls-vendored feature flag. Lua 5.4, if abel-core/mlua-vendored flag is disabled. Clone and compile the project: $ git clone https://github.com/hack3ric/abel $ cd abel $ cargo install --path cli","title":"Compile"},{"location":"getting-started/installation/#install-from-cargo","text":"Install the version published in crates.io : $ cargo install abel --locked","title":"Install from Cargo"},{"location":"getting-started/package/","text":"Package Usually a service is more than a single hello.lua and consists of several source files and resources. Abel uses asar (the same format used in Electron ) to pack these files. The entry point of a package is main.lua . Abel will first load and execute main.lua , and then load other files according to usage. Start Packing You can install asar according to its installation guide for now. In the future, Abel will include an asar packer by default. Assume that you have written a service like this: my-awesome-service/ resources/ config.json main.lua foo.lua Pack those files using asar : $ asar pack my-awesome-service my-awesome-service.asar The output asar file can be deployed by using field multi : $ curl -X PUT \\ https://abel.example.com/services/my-awesome-service \\ -F multi = @my-awesome-service.asar","title":"Package"},{"location":"getting-started/package/#package","text":"Usually a service is more than a single hello.lua and consists of several source files and resources. Abel uses asar (the same format used in Electron ) to pack these files. The entry point of a package is main.lua . Abel will first load and execute main.lua , and then load other files according to usage.","title":"Package"},{"location":"getting-started/package/#start-packing","text":"You can install asar according to its installation guide for now. In the future, Abel will include an asar packer by default. Assume that you have written a service like this: my-awesome-service/ resources/ config.json main.lua foo.lua Pack those files using asar : $ asar pack my-awesome-service my-awesome-service.asar The output asar file can be deployed by using field multi : $ curl -X PUT \\ https://abel.example.com/services/my-awesome-service \\ -F multi = @my-awesome-service.asar","title":"Start Packing"},{"location":"runtime/error-handling/","text":"","title":"Error Handling"},{"location":"runtime/file-system/","text":"File System A service have its own \"local storages\" - a folder where it has full control to read, write, rename and remove files. Abel re-implemented Lua's file APIs (for example, io.open ) to provide access to the local storage in a chroot -like manner. local text = \"I am going to be thrown into a file!\" -- Note that path - it's in the root directory! -- It's the same to use `foo.txt` - a slash is automatically added to the front. local file , err = io.open ( \"/foo.txt\" , \"w\" ) assert ( file , err ) file : write ( text ) file : close () os.rename ( \"/foo.txt\" , \"/bar.txt\" ) local file , err = io.open \"/bar.txt\" assert ( file , err ) assert ( file : read \"a\" , text ) Path There is no relative path in this environment \u2014 all paths are considered absolute. Path components like . and .. are resolved. Only UTF-8 encoded path is acceptable. Using non-UTF-8 paths will result in errors. -- The following paths are identical: io.open \"/foo/bar/baaz.txt\" io.open \"foo/bar/baaz.txt\" io.open \"/foo/im/../crazy/.././bar//baaz.txt\" -- Paths with UTF-8 characters are OK! io.open \"/\u56fe\u7247/\ud83d\ude0a.png\" -- Invalid UTF-8 path, will throw an error io.open \"/ \\x80\\x81 /test.txt\" Accessing Source Service's own source files can be accessed through URI scheme source . The open mode in io.open is ignored; the file will always open as read-only. local json = require \"json\" local file < close > , err = io.open \"source:/resources/data.json\" local data = json . parse ( file : read \"a\" ) -- Continue working on `data`... Note In a single-file service, the only file \u2014 the script itself \u2014 is located in source:/main.lua , the same as the multi-file service's entry. The fs module Apart from re-implemented functions in io and os , an all-in-one fs module is also available, containing all file system functions in standard libraries, as well as more utilities such as mkdir and metadata . local fs = require \"fs\" fs . metadata \"source:/main.lua\" -- { kind = \"file\", size = ... } fs . metadata \"/\" -- { kind = \"dir\" } fs . mkdir ( \"/foo/bar/baaz\" , true )","title":"File System"},{"location":"runtime/file-system/#file-system","text":"A service have its own \"local storages\" - a folder where it has full control to read, write, rename and remove files. Abel re-implemented Lua's file APIs (for example, io.open ) to provide access to the local storage in a chroot -like manner. local text = \"I am going to be thrown into a file!\" -- Note that path - it's in the root directory! -- It's the same to use `foo.txt` - a slash is automatically added to the front. local file , err = io.open ( \"/foo.txt\" , \"w\" ) assert ( file , err ) file : write ( text ) file : close () os.rename ( \"/foo.txt\" , \"/bar.txt\" ) local file , err = io.open \"/bar.txt\" assert ( file , err ) assert ( file : read \"a\" , text )","title":"File System"},{"location":"runtime/file-system/#path","text":"There is no relative path in this environment \u2014 all paths are considered absolute. Path components like . and .. are resolved. Only UTF-8 encoded path is acceptable. Using non-UTF-8 paths will result in errors. -- The following paths are identical: io.open \"/foo/bar/baaz.txt\" io.open \"foo/bar/baaz.txt\" io.open \"/foo/im/../crazy/.././bar//baaz.txt\" -- Paths with UTF-8 characters are OK! io.open \"/\u56fe\u7247/\ud83d\ude0a.png\" -- Invalid UTF-8 path, will throw an error io.open \"/ \\x80\\x81 /test.txt\"","title":"Path"},{"location":"runtime/file-system/#accessing-source","text":"Service's own source files can be accessed through URI scheme source . The open mode in io.open is ignored; the file will always open as read-only. local json = require \"json\" local file < close > , err = io.open \"source:/resources/data.json\" local data = json . parse ( file : read \"a\" ) -- Continue working on `data`... Note In a single-file service, the only file \u2014 the script itself \u2014 is located in source:/main.lua , the same as the multi-file service's entry.","title":"Accessing Source"},{"location":"runtime/file-system/#the-fs-module","text":"Apart from re-implemented functions in io and os , an all-in-one fs module is also available, containing all file system functions in standard libraries, as well as more utilities such as mkdir and metadata . local fs = require \"fs\" fs . metadata \"source:/main.lua\" -- { kind = \"file\", size = ... } fs . metadata \"/\" -- { kind = \"dir\" } fs . mkdir ( \"/foo/bar/baaz\" , true )","title":"The fs module"},{"location":"runtime/modifications/","text":"Modifications Abel heavily modifies Lua environment and replaces some of the Lua's standard library with its own implementation for great isolation and concurrency. It also removes \"unsafe\" functions to prevent potential sandbox escaping. Some part of the Lua standard library is removed: rawget and rawset : force metatable to be followed string.dump : provides access to function bytecode load and loadfile : access to filesystem debug : violates memory safety model os : environment and file system access package : reimplemented and moved to internal table io : stdio, process and file system access Some functions are re-implemented: Module imports has been redesigned. See Imports for more information. Error handling functions (including error , assert and pcall ) allows HTTP errors to be thrown. See Error Handling for more information. getmetatable now only accepts tables as argument. os.getenv : currently always return nil , will return environment variables specified in config file in the future. For file system-related functions in io and os , you can use those in fs module instead. Note that APIs in fs differs from those counterparts.","title":"Modifications"},{"location":"runtime/modifications/#modifications","text":"Abel heavily modifies Lua environment and replaces some of the Lua's standard library with its own implementation for great isolation and concurrency. It also removes \"unsafe\" functions to prevent potential sandbox escaping. Some part of the Lua standard library is removed: rawget and rawset : force metatable to be followed string.dump : provides access to function bytecode load and loadfile : access to filesystem debug : violates memory safety model os : environment and file system access package : reimplemented and moved to internal table io : stdio, process and file system access Some functions are re-implemented: Module imports has been redesigned. See Imports for more information. Error handling functions (including error , assert and pcall ) allows HTTP errors to be thrown. See Error Handling for more information. getmetatable now only accepts tables as argument. os.getenv : currently always return nil , will return environment variables specified in config file in the future. For file system-related functions in io and os , you can use those in fs module instead. Note that APIs in fs differs from those counterparts.","title":"Modifications"},{"location":"runtime/security/","text":"Security One core feature of Abel is security. Services' behaviour is contained within its own realm, and cannot access the outside world unless specified. Local environment On a Lua state, each service runs on their own, isolated local environment. It forms the basis of Abel's sandboxing, and you won't notice it while writing scripts. Restricted API set Abel enables a safe subset of the Lua standard library to prevent services from escaping sandbox, modifying the environment, etc. See Modifications for a detailed list of what's changed. -- Here are some examples of removed \"unsafe\" APIs. print ( rawset ) -- nil print ( os.exit ) -- nil print ( debug ) -- nil Limited file system Services are provided with a contained, chroot -like file system to persistently store files. Other part of the entire file system is inaccessible. -- No way to get that file removed \u2014 the file system's completely isolated! os.remove \"/super/important/system/file\" Automatic <close> Lua 5.4 introduced local variable attributes <const> and <close> , the latter of which provides RAII functionality similar to Rust's. Abel bring this even further: files, sockets, etc. will be automatically <close> d after exiting a certain scope, even it isn't tagged <close> . This prevents resource leaking and starvation of process resources such as file handles, as well as eliminates the need of waiting GC to do the job. abel . listen ( \"/\" , function ( req ) -- Oops, forgot to add `<close>`! local file , err = io.open ( \"/storage.csv\" , \"a\" ) assert ( file , err ) do_something ( file ) return { ... } -- Don't worry, the file will be closed at the end of the scope! end ) Warning Currently custom objects that implements the metamethod __close is not supported this feature. This may be feasible in the future. Tip Although Abel prevents resource leaking, adding <close> to those objects or freeing them after usage is always a good habit. local file < close > , err = io.open ( \"/storage.csv\" , \"a\" ) assert ( file , err ) do_something ( file ) -- or free it manually local file , err = io.open ( \"/storage.csv\" , \"a\" ) assert ( file , err ) do_something ( file ) file : close ()","title":"Security"},{"location":"runtime/security/#security","text":"One core feature of Abel is security. Services' behaviour is contained within its own realm, and cannot access the outside world unless specified.","title":"Security"},{"location":"runtime/security/#local-environment","text":"On a Lua state, each service runs on their own, isolated local environment. It forms the basis of Abel's sandboxing, and you won't notice it while writing scripts.","title":"Local environment"},{"location":"runtime/security/#restricted-api-set","text":"Abel enables a safe subset of the Lua standard library to prevent services from escaping sandbox, modifying the environment, etc. See Modifications for a detailed list of what's changed. -- Here are some examples of removed \"unsafe\" APIs. print ( rawset ) -- nil print ( os.exit ) -- nil print ( debug ) -- nil","title":"Restricted API set"},{"location":"runtime/security/#limited-file-system","text":"Services are provided with a contained, chroot -like file system to persistently store files. Other part of the entire file system is inaccessible. -- No way to get that file removed \u2014 the file system's completely isolated! os.remove \"/super/important/system/file\"","title":"Limited file system"},{"location":"runtime/security/#automatic-close","text":"Lua 5.4 introduced local variable attributes <const> and <close> , the latter of which provides RAII functionality similar to Rust's. Abel bring this even further: files, sockets, etc. will be automatically <close> d after exiting a certain scope, even it isn't tagged <close> . This prevents resource leaking and starvation of process resources such as file handles, as well as eliminates the need of waiting GC to do the job. abel . listen ( \"/\" , function ( req ) -- Oops, forgot to add `<close>`! local file , err = io.open ( \"/storage.csv\" , \"a\" ) assert ( file , err ) do_something ( file ) return { ... } -- Don't worry, the file will be closed at the end of the scope! end ) Warning Currently custom objects that implements the metamethod __close is not supported this feature. This may be feasible in the future. Tip Although Abel prevents resource leaking, adding <close> to those objects or freeing them after usage is always a good habit. local file < close > , err = io.open ( \"/storage.csv\" , \"a\" ) assert ( file , err ) do_something ( file ) -- or free it manually local file , err = io.open ( \"/storage.csv\" , \"a\" ) assert ( file , err ) do_something ( file ) file : close ()","title":"Automatic &lt;close&gt;"},{"location":"server/config/","text":"Configuration Abel's server configuration files is located in $ABEL_DIR/config.json , where $ABEL_DIR defaults to ~/.abel . A default configuration files looks like this: { \"listen\" : \"127.0.0.1:3000\" , \"auth_token\" : \"<random-auth-token>\" , \"pool_size\" : null } The configurable options are: listen : The address Abel server will be listening to. Defaults to 127.0.0.1:3000 auth_token : Authentication token in UUID format. This can be set to null to remove authentication, but don't do this in production environment! pool_size : Lua executor count. Defaults to std::thread::available_parallelism() / 2 if the value is set to null . These options are temporarily overridable with command line options. The config.json will not be changed. $ abel-server --listen 0 .0.0.0:1024 --auth-token <new-auth-token> INFO abel_server > Authentication token: <new-auth-token> INFO abel_server > Abel is listening to 0.0.0.0:1024","title":"Configuration"},{"location":"server/config/#configuration","text":"Abel's server configuration files is located in $ABEL_DIR/config.json , where $ABEL_DIR defaults to ~/.abel . A default configuration files looks like this: { \"listen\" : \"127.0.0.1:3000\" , \"auth_token\" : \"<random-auth-token>\" , \"pool_size\" : null } The configurable options are: listen : The address Abel server will be listening to. Defaults to 127.0.0.1:3000 auth_token : Authentication token in UUID format. This can be set to null to remove authentication, but don't do this in production environment! pool_size : Lua executor count. Defaults to std::thread::available_parallelism() / 2 if the value is set to null . These options are temporarily overridable with command line options. The config.json will not be changed. $ abel-server --listen 0 .0.0.0:1024 --auth-token <new-auth-token> INFO abel_server > Authentication token: <new-auth-token> INFO abel_server > Abel is listening to 0.0.0.0:1024","title":"Configuration"}]}